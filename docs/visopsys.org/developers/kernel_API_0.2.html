<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Visopsys Developer Page</title>

<meta name="Microsoft Border" content="lrb">
</head>

<body bgcolor="#285DAB" text="#FFFFFF" link="#FFFF00" vlink="#00FF00" background="../img/background.jpg"><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%">
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="93">
  <tr>
    <td width="99"><p align="center"><font color="#FFFFFF"><a href="../index.html">
    <img src="../img/nav_buttons/home.gif" alt="Home" border="0" align="middle" width="53" height="25"></a><br>
    <br>
    <a href="../about/index.html">
    <img src="../img/nav_buttons/about.gif" alt="About" border="0" align="middle" width="60" height="25"></a></font><p align="center">
    <a href="../about/news.html">
    <img border="0" src="../img/nav_buttons/news.gif" alt="News" width="49" height="16"></a><br>
    <br>
    <a href="../about/screenshots.html">
    <img border="0" src="../img/nav_buttons/screenshots.gif" alt="Screenshots" width="105" height="22"></a><font color="#FFFFFF"><br>
    <br>
    <a href="../download/index.html">
    <img src="../img/nav_buttons/download.gif" alt="Download" border="0" align="middle" width="95" height="25"></a></font><br>
    <br>
    <a href="index.html">
    <img src="../img/nav_buttons/developers.gif" border="0" alt="Developers" align="middle" width="97" height="29"></a><br>
    <br>
    <a href="../osdev/index.html">
    <img src="../img/nav_buttons/osdev.gif" border="0" alt="OS Development" align="middle" width="64" height="25"></a><br>
    <br>
    <a href="../search.html">
    <img src="../img/nav_buttons/search.gif" alt="Search" align="middle" border="0" width="63" height="24"></a></td>
  </tr>
</table>
</center></div>

</td><td valign="top" width="24"></td><!--msnavigation--><td valign="top">

<p align="center">&nbsp;</p>

<p align="center">
<img src="../img/banners/visopsys-logo.gif" align="middle" border="0" width="291" height="94"><br>
<img src="../img/banners/visopsys-developers.gif" border="0" align="middle" width="291" height="56"></p>

<p align="left"><b><font size="4">THE VISOPSYS KERNEL API&nbsp; (version 0.2)<br>
(The <a href="index.html">current version</a> is 0.3)</font></b></p>

<p align="left"><font size="4">All of the kernel's functions are defined in the 
file /system/headers/sys/api.h.&nbsp; Going forward, this file may be split into 
more manageable chunks.&nbsp; Data structures referred to in these function 
definitions are found in the applicable header file in /system/headers/sys.&nbsp; 
For example, a 'disk' object is defined in /system/headers/sys/disk.h.</font></p>

<blockquote>

<p align="left"><i>One note on the 'objectKey' type used by many of these 
functions: This is used to refer to data structures in kernel memory that are 
not accessible (in a practical sense) to external programs.&nbsp; Yes, it's a 
pointer -- A pointer to a structure that is probably defined in one of the 
kernel header files.&nbsp; You could try to use it as more than just a reference 
key, but you would do so at your own risk.</i></p>

</blockquote>

<p align="left"><font size="4">Here is the breakdown of functions available at 
the time of writing:</font></p>

<p><font size="4"><a href="#text">Text input/output functions</a><br>
<a href="#disk">Disk functions</a><br>
<a href="#filesystem">Filesystem functions</a><br>
<a href="#file">File functions</a><br>
<a href="#memory">Memory functions</a><br>
<a href="#multitasker">Multitasker functions</a><br>
<a href="#loader">Loader functions</a><br>
<a href="#realtime">Real-time clock functions</a><br>
<a href="#random">Random number functions</a><br>
<a href="#environment">Environment functions</a><br>
<a href="#graphics">Raw graphics functions</a><br>
<a href="#window">Window manager functions</a><br>
<a href="#misc">Miscellaneous functions</a></font></p>
<p>&nbsp;</p>
<p><b><font size="4"><a name="text"></a>Text input/output functions</font></b></p>
<p><font face="Courier New">int textGetForeground(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the current foreground color as an int 
  value.&nbsp; Currently this is only applicable in text mode, and the color 
  value should be treated as a PC built-in color value.&nbsp; Here is a listing:</font></p>
  <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td width="25%"><font face="Times New Roman">0 - Black</font></td>
      <td width="25%"><font face="Times New Roman">4 - Red</font></td>
      <td width="25%"><font face="Times New Roman">8 - Dark gray</font></td>
      <td width="25%"><font face="Times New Roman">12 - Light red</font></td>
    </tr>
    <tr>
      <td width="25%"><font face="Times New Roman">1 - Blue</font></td>
      <td width="25%"><font face="Times New Roman">5 - Magenta</font></td>
      <td width="25%"><font face="Times New Roman">9 - Light blue</font></td>
      <td width="25%"><font face="Times New Roman">13 - Light magenta</font></td>
    </tr>
    <tr>
      <td width="25%"><font face="Times New Roman">2 - Green</font></td>
      <td width="25%"><font face="Times New Roman">6 - Brown</font></td>
      <td width="25%"><font face="Times New Roman">10 - Light green</font></td>
      <td width="25%"><font face="Times New Roman">14 - Yellow</font></td>
    </tr>
    <tr>
      <td width="25%"><font face="Times New Roman">3 - Cyan</font></td>
      <td width="25%"><font face="Times New Roman">7 - Light gray</font></td>
      <td width="25%"><font face="Times New Roman">11 - Light cyan</font></td>
      <td width="25%"><font face="Times New Roman">15 - White</font></td>
    </tr>
  </table>
</blockquote>
<p><font face="Courier New">int textSetForeground(int foreground)</font></p>
<blockquote>
  <p><font face="Times New Roman">Set the current foreground color from an int 
  value.&nbsp; Currently this is only applicable in text mode, and the color 
  value should be treated as a PC builtin color value.&nbsp; See chart above.</font></p>
</blockquote>
<p><font face="Courier New">int textGetBackground(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the current background color as an int 
  value.&nbsp; Currently this is only applicable in text mode, and the color 
  value should be treated as a PC builtin color value.&nbsp; See chart above.</font></p>
</blockquote>
<p><font face="Courier New">int textSetBackground(int background)</font></p>
<blockquote>
  <p><font face="Times New Roman">Set the current foreground color from an int 
  value.&nbsp; Currently this is only applicable in text mode, and the color 
  value should be treated as a PC builtin color value.&nbsp; See chart above.</font></p>
</blockquote>
<p><font face="Courier New">int textPutc(int ascii)</font></p>
<blockquote>
  <p><font face="Times New Roman">Print a single character</font></p>
</blockquote>
<p><font face="Courier New">int textPrint(const char *str)</font></p>
<blockquote>
  <p><font face="Times New Roman">Print a string</font></p>
</blockquote>
<p><font face="Courier New">int textPrintLine(const char *str)</font></p>
<blockquote>
  <p><font face="Times New Roman">Print a string with a newline at the end</font></p>
</blockquote>
<p><font face="Courier New">void textNewline(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Print a newline</font></p>
</blockquote>
<p><font face="Courier New">int textBackSpace(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Backspace the cursor, deleting any character 
  there</font></p>
</blockquote>
<p><font face="Courier New">int textTab(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Print a tab</font></p>
</blockquote>
<p><font face="Courier New">int textCursorUp(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Move the cursor up one row.&nbsp; Doesn't 
  affect any characters there.</font></p>
</blockquote>
<p><font face="Courier New">int textCursorDown(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Move the cursor down one row.&nbsp; Doesn't 
  affect any characters there.</font></p>
</blockquote>
<p><font face="Courier New">int textCursorLeft(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Move the cursor left one column.&nbsp; Doesn't 
  affect any characters there.</font></p>
</blockquote>
<p><font face="Courier New">int textCursorRight(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Move the cursor right one column.&nbsp; 
  Doesn't affect any characters there.</font></p>
</blockquote>
<p><font face="Courier New">int textGetNumColumns(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the total number of columns in the text 
  area.</font></p>
</blockquote>
<p><font face="Courier New">int textGetNumRows(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the total number of rows in the text area.</font></p>
</blockquote>
<p><font face="Courier New">int textGetColumn(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the number of the current column.&nbsp; 
  Zero-based.</font></p>
</blockquote>
<p><font face="Courier New">void textSetColumn(int c)</font></p>
<blockquote>
  <p><font face="Times New Roman">Set the number of the current column.&nbsp; 
  Zero-based.&nbsp; Doesn't affect any characters there.</font></p>
</blockquote>
<p><font face="Courier New">int textGetRow(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the number of the current row.&nbsp; 
  Zero-based.</font></p>
</blockquote>
<p><font face="Courier New">void textSetRow(int r)</font></p>
<blockquote>
  <p><font face="Times New Roman">Set the number of the current row.&nbsp; 
  Zero-based.&nbsp; Doesn't affect any characters there.</font></p>
</blockquote>
<p><font face="Courier New">int textClearScreen(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Erase all characters in the text area and set 
  the row and column to (0, 0)</font></p>
</blockquote>
<p><font face="Courier New">int textInputCount(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the number of characters currently waiting 
  in the input stream</font></p>
</blockquote>
<p><font face="Courier New">int textInputGetc(char *cp)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get one character from the input stream (as an 
  integer value).</font></p>
</blockquote>
<p><font face="Courier New">int textInputReadN(int num, char *buff)</font></p>
<blockquote>
  <p><font face="Times New Roman">Read up to 'num' characters from the input 
  stream into 'buff'</font></p>
</blockquote>
<p><font face="Courier New">int textInputReadAll(char *buff)</font></p>
<blockquote>
  <p><font face="Times New Roman">Read all of the characters from the input 
  stream into 'buff'</font></p>
</blockquote>
<p><font face="Courier New">int textInputAppend(int ascii)</font></p>
<blockquote>
  <p><font face="Times New Roman">Append a character (as an integer value) to 
  the end of the input stream.</font></p>
</blockquote>
<p><font face="Courier New">int textInputAppendN(int num, char *str)</font></p>
<blockquote>
  <p><font face="Times New Roman">Append 'num' characters to the end of the 
  input stream from 'str'</font></p>
</blockquote>
<p><font face="Courier New">int textInputRemove(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Remove one character from the start of the 
  input stream.</font></p>
</blockquote>
<p><font face="Courier New">int textInputRemoveN(int num)</font></p>
<blockquote>
  <p><font face="Times New Roman">Remove 'num' characters from the start of the 
  input stream.</font></p>
</blockquote>
<p><font face="Courier New">int textInputRemoveAll(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Empty the input stream.</font></p>
</blockquote>
<p><font face="Courier New">void textInputSetEcho(int onOff)</font></p>
<blockquote>
  <p><font face="Times New Roman">Set echo on (1) or off (0) for the input 
  stream.&nbsp; When on, any characters typed will be automatically printed to 
  the text area.&nbsp; When off, they won't.</font></p>
</blockquote>
<p>&nbsp;</p>
<p><b><font size="4"><a name="disk"></a>Disk functions</font></b></p>
<p><font face="Courier New">int diskFunctionsGetBoot(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the internal disk number of the boot 
  device.&nbsp; Normally this will contain the root filesystem.</font></p>
</blockquote>
<p><font face="Courier New">int diskFunctionsGetCount(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the number of disk volumes recognized by 
  the system</font></p>
</blockquote>
<p><font face="Courier New">int diskFunctionsGetInfo(int num, disk *d)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get information about the disk volume 'num' 
  and put it in the disk structure d.&nbsp; The disk numbers are sequential, so 
  you 'num' can be any value from 0 to </font><font face="Courier New">
  diskFunctionsGetCount()</font><font face="Times New Roman">. </font></p>
</blockquote>
<p><font face="Courier New">int diskFunctionsMotorOn(int num)</font></p>
<blockquote>
  <p><font face="Times New Roman">Turn the disk motor of disk 'num' on, if 
  applicable.&nbsp; Generally only applicable to removable devices like 
  floppies.</font></p>
</blockquote>
<p><font face="Courier New">int diskFunctionsMotorOff(int num)</font></p>
<blockquote>
  <p><font face="Times New Roman">Turn the disk motor of disk 'num' off, if 
  applicable.&nbsp; Generally only applicable to removable devices like 
  floppies.</font></p>
</blockquote>
<p><font face="Courier New">int diskFunctionsDiskChanged(int num)</font></p>
<blockquote>
  <p><font face="Times New Roman">Return 1 if disk 'num' is a removable device 
  such as a floppy or CD-ROM, and the media has been changed or removed.</font></p>
</blockquote>
<p><font face="Courier New">int diskFunctionsReadSectors(int num, unsigned sect, 
unsigned count, void *buf)</font></p>
<blockquote>
  <p><font face="Times New Roman">Read 'count' sectors from disk 'num', starting 
  at (zero-based) logical sector number 'sect'.&nbsp; Put the data in memory 
  area 'buf'.</font></p>
</blockquote>
<p><font face="Courier New">int diskFunctionsWriteSectors(int num, unsigned 
sect, unsigned count, void *buf)</font></p>
<blockquote>
  <p><font face="Times New Roman">Write 'count' sectors to disk 'num', starting 
  at (zero-based) logical sector number 'sect'.&nbsp; Get the data from memory 
  area 'buf'.</font></p>
</blockquote>
<p><font face="Courier New">int diskFunctionsReadAbsoluteSectors(int num, 
unsigned sect, unsigned count, void *buf)</font></p>
<blockquote>
  <p><font face="Times New Roman">Read 'count' sectors from disk 'num', starting 
  at (zero-based) absolute sector number 'sect'.&nbsp; Put the data in memory 
  area 'buf'.&nbsp; This function requires supervisor privilege and is used to 
  read outside the logical confines of a volume, such as a hard disk partition.&nbsp; 
  Not very useful unless you know what you're doing.</font></p>
</blockquote>
<p><font face="Courier New">int diskFunctionsWriteAbsoluteSectors(int num, 
unsigned sect, unsigned count, void *buf)</font></p>
<blockquote>
  <p><font face="Times New Roman">Write 'count' sectors to disk 'num', starting 
  at (zero-based) absolute sector number 'sect'.&nbsp; Get the data from memory 
  area 'buf'.&nbsp; This function requires supervisor privilege and is used to 
  write outside the logical confines of a volume, such as a hard disk partition.&nbsp; 
  Don't use this unless you know what you're doing.</font></p>
</blockquote>
<p>&nbsp;</p>
<p><b><font size="4"><a name="filesystem"></a>Filesystem functions</font></b></p>
<p><font face="Courier New">int filesystemCheck(int disknum, int force, int 
repair)</font></p>
<blockquote>
  <p><font face="Times New Roman">Check the filesystem on disk 'disknum'.&nbsp; 
  If 'force' is non-zero, the filesystem will be checked regardless of whether 
  the filesystem driver thinks it needs to be.&nbsp; If 'repair' is non-zero, 
  the filesystem driver will attempt to repair any errors found.&nbsp; If 
  'repair' is zero, a non-zero return value may indicate that errors were found.&nbsp; 
  If 'repair' is non-zero, a non-zero return value may indicate that errors were 
  found but could not be fixed.&nbsp; It is optional for filesystem drivers to 
  implement this function.</font></p>
</blockquote>
<p><font face="Courier New">int filesystemDefragment(int disknum)</font></p>
<blockquote>
  <p><font face="Times New Roman">Defragment the filesystem on disk 'disknum'.&nbsp; 
  It is optional for filesystem drivers to implement this function.</font></p>
</blockquote>
<p><font face="Courier New">int filesystemMount(int disknum, const char *mp)</font></p>
<blockquote>
  <p><font face="Times New Roman">Mount the filesystem on disk 'disknum', using 
  the mount point specified by the absolute pathname 'mp'.&nbsp; Note that no 
  file or directory called 'mp' should exist, as the mount function will expect 
  to be able to create it.</font></p>
</blockquote>
<p><font face="Courier New">int filesystemSync(const char *fs)</font></p>
<blockquote>
  <p><font face="Times New Roman">Synchronize the filesystem mounted represented 
  by the mount point 'fs'.</font></p>
</blockquote>
<p><font face="Courier New">int filesystemUnmount(const char *mp)</font></p>
<blockquote>
  <p><font face="Times New Roman">Unmount the filesystem mounted represented by 
  the mount point 'fs'.</font></p>
</blockquote>
<p><font face="Courier New">int filesystemNumberMounted(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Returns the number of filesystems currently 
  mounted.</font></p>
</blockquote>
<p><font face="Courier New">void filesystemFirstFilesystem(char *buff)</font></p>
<blockquote>
  <p><font face="Times New Roman">Returns the mount point of the first mounted 
  filesystem in 'buff'.&nbsp; Normally this will be the root filesystem &quot;/&quot;.</font></p>
</blockquote>
<p><font face="Courier New">void filesystemNextFilesystem(char *buff)</font></p>
<blockquote>
  <p><font face="Times New Roman">Returns the mount point of the next mounted 
  filesystem as returned by a previous call to either </font>
  <font face="Courier New">filesystemFirstFilesystem()</font><font face="Times New Roman">or
  </font><font face="Courier New">filesystemNextFilesystem()</font></p>
</blockquote>
<p><font face="Courier New">int filesystemGetFree(const char *fs)</font></p>
<blockquote>
  <p><font face="Times New Roman">Returns the amount of free space on the 
  filesystem represented by the mount point 'fs'.</font></p>
</blockquote>
<p><font face="Courier New">unsigned int filesystemGetBlockSize(const char *fs)</font></p>
<blockquote>
  <p><font face="Times New Roman">Returns the block size (for example, 512 or 
  1024) of the filesystem represented by the mount point 'fs'.</font></p>
</blockquote>
<p>&nbsp;</p>
<p><b><font size="4"><a name="file"></a>File functions</font></b></p>
<p><font size="4">Note that in all of the functions of this section, any 
reference to pathnames means absolute pathnames, from root.&nbsp; E.g. '/files/myfile', 
not simply 'myfile'.&nbsp; From the kernel's point of view, 'myfile' might be 
ambiguous.</font></p>
<p><font face="Courier New">int fileFixupPath(const char *orig, char *new)</font></p>
<blockquote>
  <p><font face="Times New Roman">Take the absolute pathname in 'orig' and fix 
  it up.&nbsp; This means eliminating extra file separator characters (for 
  example) and resolving links or '.' or '..' components in the pathname.</font></p>
</blockquote>
<p><font face="Courier New">int fileFirst(const char *path, file *f)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the first file from the directory 
  referenced by 'path'.&nbsp; Put the information in the file structure 'f'.</font></p>
</blockquote>
<p><font face="Courier New">int fileNext(const char *path, file *f)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the next file from the directory 
  referenced by 'path'.&nbsp; 'f' should be a file structure previously filled 
  by a call to either </font><font face="Courier New">fileFirst()</font><font face="Times New Roman"> 
  or </font><font face="Courier New">fileNext()</font><font face="Times New Roman">.</font></p>
</blockquote>
<p><font face="Courier New">int fileFind(const char *name, file *f)</font></p>
<blockquote>
  <p><font face="Times New Roman">Find the file referenced by 'name', and fill 
  the file data structure 'f' with the results if successful.</font></p>
</blockquote>
<p><font face="Courier New">int fileOpen(const char *name, int mode, file *f)</font></p>
<blockquote>
  <p><font face="Times New Roman">Open the file referenced by 'name' using the 
  file open mode 'mode' (defined in &lt;sys/file.h&gt;).&nbsp; Update the file data 
  structure 'f' if successful.</font></p>
</blockquote>
<p><font face="Courier New">int fileClose(file *f)</font></p>
<blockquote>
  <p><font face="Times New Roman">Close the previously opened file 'f'.</font></p>
</blockquote>
<p><font face="Courier New">int fileRead(file *f, unsigned int blocknum, 
unsigned int blocks, unsigned char *buff)</font></p>
<blockquote>
  <p><font face="Times New Roman">Read data from the previously opened file 'f'.&nbsp; 
  'f' should have been opened in a read or read/write mode.&nbsp; Read 'blocks' 
  blocks (see the filesystem functions for information about getting the block 
  size of a given filesystem) and put them in buffer 'buff'.</font></p>
</blockquote>
<p><font face="Courier New">int fileWrite(file *f, unsigned int blocknum, 
unsigned int blocks, unsigned char *buff)</font></p>
<blockquote>
  <p><font face="Times New Roman">Write data to the previously opened file 'f'.&nbsp; 
  'f' should have been opened in a write or read/write mode.&nbsp; Write 
  'blocks' blocks (see the filesystem functions for information about getting 
  the block size of a given filesystem) from the buffer 'buff'.</font></p>
</blockquote>
<p><font face="Courier New">int fileDelete(const char *name)</font></p>
<blockquote>
  <p><font face="Times New Roman">Delete the file referenced by the pathname 
  'name'.</font></p>
</blockquote>
<p><font face="Courier New">int fileDeleteSecure(const char *name)</font></p>
<blockquote>
  <p><font face="Times New Roman">Securely delete the file referenced by the 
  pathname 'name'.&nbsp; If supported.</font></p>
</blockquote>
<p><font face="Courier New">int fileMakeDir(const char *name)</font></p>
<blockquote>
  <p><font face="Times New Roman">Create a directory to be referenced by the 
  pathname 'name'.</font></p>
</blockquote>
<p><font face="Courier New">int fileRemoveDir(const char *name)</font></p>
<blockquote>
  <p><font face="Times New Roman">Remove the directory referenced by the 
  pathname 'name'.</font></p>
</blockquote>
<p><font face="Courier New">int fileCopy(const char *src, const char *dest)</font></p>
<blockquote>
  <p><font face="Times New Roman">Copy the file referenced by the pathname 'src' 
  to the pathname 'dest'.&nbsp; This will overwrite 'dest' if it already exists.</font></p>
</blockquote>
<p><font face="Courier New">int fileCopyRecursive(const char *src, const char *dest)</font></p>
<blockquote>
  <p><font face="Times New Roman">Recursively copy the file referenced by the 
  pathname 'src' to the pathname 'dest'.&nbsp; If 'src' is a regular file, the 
  result will be the same as using the non-recursive call.&nbsp; However if it 
  is a directory, all contents of the directory and its subdirectories will be 
  copied.&nbsp; This will overwrite any files in the 'dest' tree if they already 
  exist.</font></p>
</blockquote>
<p><font face="Courier New">int fileMove(const char *src, const char *dest)</font></p>
<blockquote>
  <p><font face="Times New Roman">Move (rename) a file referenced by the 
  pathname 'src' to the pathname 'dest'.</font></p>
</blockquote>
<p><font face="Courier New">int fileTimestamp(const char *name)</font></p>
<blockquote>
  <p><font face="Times New Roman">Update the time stamp on the file referenced 
  by the pathname 'name'</font></p>
</blockquote>
<p><font face="Courier New">int fileStreamOpen(const char *name, int mode, 
fileStream *f)</font></p>
<blockquote>
  <p><font face="Times New Roman">Open the file referenced by the pathname 
  'name' for streaming operations, using the open mode 'mode' (defined in &lt;sys/file.h&gt;).&nbsp; 
  Fills the fileStream data structure 'f' with information needed for subsequent 
  file stream operations.</font></p>
</blockquote>
<p><font face="Courier New">int fileStreamSeek(fileStream *f, int offset)</font></p>
<blockquote>
  <p><font face="Times New Roman">Seek the file stream 'f' to the absolute 
  position 'offset'</font></p>
</blockquote>
<p><font face="Courier New">int fileStreamRead(fileStream *f, int bytes, char 
*buff)</font></p>
<blockquote>
  <p><font face="Times New Roman">Read 'bytes' bytes from the filestream 'f' and 
  put them into 'buff'.</font></p>
</blockquote>
<p><font face="Courier New">int fileStreamWrite(fileStream *f, int bytes, char 
*buff)</font></p>
<blockquote>
  <p><font face="Times New Roman">Write 'bytes' bytes from the buffer 'buff' to 
  the file stream 'f'.</font></p>
</blockquote>
<p><font face="Courier New">int fileStreamFlush(fileStream *f)</font></p>
<blockquote>
  <p><font face="Times New Roman">Flush file stream 'f'.</font></p>
</blockquote>
<p><font face="Courier New">int fileStreamClose(fileStream *f)</font></p>
<blockquote>
  <p><font face="Times New Roman">[Flush and] close the file stream 'f'.</font></p>
</blockquote>
<p>&nbsp;</p>
<p><b><font size="4"><a name="memory"></a>Memory functions</font></b></p>
<p><font face="Courier New">void memoryPrintUsage(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Prints the current memory usage statistics to 
  the current output stream.</font></p>
</blockquote>
<p><font face="Courier New">void *memoryRequestBlock(unsigned int size, unsigned 
int align, const char *desc)</font></p>
<blockquote>
  <p><font face="Times New Roman">Return a pointer to a new block of memory of 
  size 'size' and (optional) physical alignment 'align', adding the (optional) 
  description 'desc'.&nbsp; If no specific alignment is required, use '0'.&nbsp; 
  Memory allocated using this function is automatically cleared (like 'calloc').</font></p>
</blockquote>
<p><font face="Courier New">void *memoryRequestPhysicalBlock(unsigned int size, 
unsigned int align, const char *desc)</font></p>
<blockquote>
  <p><font face="Times New Roman">Return a pointer to a new physical block of 
  memory of size 'size' and (optional) physical alignment 'align', adding the 
  (optional) description 'desc'.&nbsp; If no specific alignment is required, use 
  '0'.&nbsp; Memory allocated using this function is NOT automatically cleared.&nbsp; 
  'Physical' refers to an actual physical memory address, and is not necessarily 
  useful to external programs.</font></p>
</blockquote>
<p><font face="Courier New">int memoryReleaseBlock(void *p)</font></p>
<blockquote>
  <p><font face="Times New Roman">Release the memory block starting at the 
  address 'p'.&nbsp; Must have been previously allocated using the </font>
  <font face="Courier New">memoryRequestBlock() </font>
  <font face="Times New Roman">function.</font></p>
</blockquote>
<p><font face="Courier New">int memoryReleaseAllByProcId(int pid)</font></p>
<blockquote>
  <p><font face="Times New Roman">Release all memory allocated to/by the process 
  referenced by process ID 'pid'.&nbsp; Only privileged functions can release 
  memory owned by other processes.</font></p>
</blockquote>
<p><font face="Courier New">int memoryChangeOwner(int opid, int npid, void *addr, 
void **naddr)</font></p>
<blockquote>
  <p><font face="Times New Roman">Change the ownership of an allocated block of 
  memory beginning at address 'addr'.&nbsp; 'opid' is the process ID of the 
  currently owning process, and 'npid' is the process ID of the intended new 
  owner.&nbsp; 'naddr' is filled with the new address of the memory (since it 
  changes address spaces in the process).&nbsp; Note that only a privileged 
  process can change memory ownership.</font></p>
</blockquote>
<p>&nbsp;</p>
<p><b><font size="4"><a name="multitasker"></a>Multitasker functions</font></b></p>
<p><font face="Courier New">int multitaskerCreateProcess(void *addr, unsigned 
int size, const char *name, int numargs, void *args)</font></p>
<blockquote>
  <p><font face="Times New Roman">Create a new process.&nbsp; The code should 
  have been loaded at the address 'addr' and be of size 'size'.&nbsp; 'name' 
  will be the new process' name.&nbsp; 'numargs' and 'args' will be passed as 
  the &quot;int argc, char *argv[]) parameters of the new process.&nbsp; If there are 
  no arguments, these should be 0 and NULL, respectively.&nbsp; If the value 
  returned by the call is a positive integer, the call was successful and the 
  value is the new process' process ID.&nbsp; New processes are created and left 
  in a stopped state, so if you want it to run you will need to set it to a 
  running state ('ready', actually) using the function call </font>
  <font face="Courier New">multitaskerSetProcessState()</font><font face="Times New Roman">.</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerSpawn(void *addr, const char *name, 
int</font><font face="Courier New"> numargs, void *args)</font></p>
<blockquote>
  <p><font face="Times New Roman">Spawn a thread from the current process.&nbsp; 
  The starting point of the code (for example, a function address) should be 
  specified as 'addr'.&nbsp; 'name' will be the new thread's name.&nbsp; 'numargs' 
  and 'args' will be passed as the &quot;int argc, char *argv[]) parameters of the 
  new thread.&nbsp; If there are no arguments, these should be 0 and NULL, 
  respectively.&nbsp; If the value returned by the call is a positive integer, 
  the call was successful and the value is the new thread's process ID.&nbsp; 
  New threads are created and left in a stopped state, so if you want it to run 
  you will need to set it to a running state ('ready', actually) using the 
  function call </font><font face="Courier New">multitaskerSetProcessState()</font><font face="Times New Roman">.</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerGetCurrentProcessId(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Returns the process ID of the calling program.</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerGetProcessOwner(int pid)</font></p>
<blockquote>
  <p><font face="Times New Roman">Returns the user ID of the user that owns the 
  process referenced by process ID 'pid'.</font></p>
</blockquote>
<p><font face="Courier New">const char *multitaskerGetProcessName(int pid)</font></p>
<blockquote>
  <p><font face="Times New Roman">Returns the process name of the process 
  referenced by process ID 'pid'.</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerGetProcessState(int pid, int *statep)</font></p>
<blockquote>
  <p><font face="Times New Roman">Gets the state of the process referenced by 
  process ID 'pid'.&nbsp; Puts the result in 'statep'.</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerSetProcessState(int pid, int state)</font></p>
<blockquote>
  <p><font face="Times New Roman">Sets the state of the process referenced by 
  process ID 'pid' to the new state 'state'.</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerGetProcessPriority(int pid)</font></p>
<blockquote>
  <p><font face="Times New Roman">Gets the priority of the process referenced by 
  process ID 'pid'.</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerSetProcessPriority(int pid, int 
priority)</font></p>
<blockquote>
  <p><font face="Times New Roman">Sets the priority of the process referenced by 
  process ID 'pid' to 'priority'..</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerGetProcessPrivilege(int pid)</font></p>
<blockquote>
  <p><font face="Times New Roman">Gets the privilege level of the process 
  referenced by process ID 'pid'.</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerGetCurrentDirectory(char *buff, int 
buffsz)</font></p>
<blockquote>
  <p>Returns the absolute pathname of the calling process' current directory.&nbsp; 
  Puts the value in the buffer 'buff' which is of size 'buffsz'.</p>
</blockquote>
<p><font face="Courier New">int multitaskerSetCurrentDirectory(char *buff)</font></p>
<blockquote>
  <p><font face="Times New Roman">Sets the current directory of the calling 
  process to the absolute pathname 'buff'.</font></p>
</blockquote>
<p><font face="Courier New">objectKey multitaskerGetTextInput(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get an object key to refer to the current text 
  input stream of the calling process.</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerSetTextInput(int processId, objectKey 
key)</font></p>
<blockquote>
  <p><font face="Times New Roman">Set the text input stream of the process 
  referenced by process ID 'processId' to a text stream referenced by the object 
  key 'key'.</font></p>
</blockquote>
<p><font face="Courier New">objectKey multitaskerGetTextOutput(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get an object key to refer to the current text 
  output stream of the calling process.</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerSetTextOutput(int processId, 
objectKey key)</font></p>
<blockquote>
  <p><font face="Times New Roman">Set the text output stream of the process 
  referenced by process ID 'processId' to a text stream referenced by the object 
  key 'key'.</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerGetProcessorTime(clock_t *clk)</font></p>
<blockquote>
  <p><font face="Times New Roman">Fill the clock_t structure with the amount of 
  processor time consumed by the calling process.</font></p>
</blockquote>
<p><font face="Courier New">void multitaskerYield(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Yield the remainder of the current processor 
  timeslice back to the multitasker's scheduler.&nbsp; It's nice to do this when 
  you are waiting for some event, so that your process is not 'hungry' (i.e. 
  hogging processor cycles unnecessarily).</font></p>
</blockquote>
<p><font face="Courier New">void multitaskerWait(unsigned int ticks)</font></p>
<blockquote>
  <p><font face="Times New Roman">Yield the remainder of the current processor 
  timeslice back to the multitasker's scheduler, and wait at least 'ticks' timer 
  ticks before running the calling process again.&nbsp; On the PC, one second is 
  approximately 20 system timer ticks.</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerBlock(int pid)</font></p>
<blockquote>
  <p><font face="Times New Roman">Yield the remainder of the current processor 
  timeslice back to the multitasker's scheduler, and block on the process 
  referenced by process ID 'pid'.&nbsp; This means that the calling process will 
  not run again until process 'pid' has terminated.&nbsp; The return value of 
  this function is the return value of process 'pid'.</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerKillProcess(int pid, int force)</font></p>
<blockquote>
  <p><font face="Times New Roman">Terminate the process referenced by process ID 
  'pid'.&nbsp; If 'force' is non-zero, the multitasker will attempt to ignore 
  any errors and dismantle the process with extreme prejudice.&nbsp; The 'force' 
  flag also has the necessary side effect of killing any child threads spawned 
  by process 'pid'.&nbsp; (Otherwise, 'pid' is left in a stopped state until its 
  threads have terminated normally).</font></p>
</blockquote>
<p><font face="Courier New">int multitaskerTerminate(int code)</font></p>
<blockquote>
  <p><font face="Times New Roman">Terminate the calling process, returning the 
  exit code 'code'</font></p>
</blockquote>
<p><font face="Courier New">void multitaskerDumpProcessList(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Print a listing of all current processes to 
  the current text output stream.&nbsp; Might not be the current output stream 
  of the calling process, but rather the console output stream.&nbsp; This could 
  be considered a bug, but is more of a &quot;currently necessary peculiarity&quot;.</font></p>
</blockquote>
<p>&nbsp;</p>
<p><b><font size="4"><a name="loader"></a>Loader functions</font></b></p>
<p><font face="Courier New">void loaderLoad(const char *filename, file *theFile)</font></p>
<blockquote>
  <p><font face="Times New Roman">Load a file referenced by the pathname 
  'filename', and fill the file data structure 'theFile' with the details.</font></p>
</blockquote>
<p><font face="Courier New">int loaderLoadProgram(const char *userProgram, int 
privilege, int</font><font face="Courier New"> argc, char *argv[])</font></p>
<blockquote>
  <p><font face="Times New Roman">Load the file referenced by the pathname 'userProgram' 
  as a process with the privilege level 'privilege'.&nbsp; Pass the arguments 'argc' 
  and 'argv'.&nbsp; If there are no arguments, these should be 0 and NULL, 
  respectively.&nbsp; If successful, the call's return value is the process ID 
  of the new process.&nbsp; The process is left in a stopped state and must be 
  set to a running state explicitly using the multitasker function </font>
  <font face="Courier New">multitaskerSetProcessState()</font><font face="Times New Roman"> 
  or the loader function </font><font face="Courier New">loaderExecProgram()</font><font face="Times New Roman">.</font></p>
</blockquote>
<p><font face="Courier New">int loaderExecProgram(int processId, int block)</font></p>
<blockquote>
  <p><font face="Times New Roman">Execute the process referenced by process ID 'processId'.&nbsp; 
  If 'block' is non-zero, the calling process will block until process 'pid' has 
  terminated, and the return value of the call is the return value of process 'pid'.</font></p>
</blockquote>
<p><font face="Courier New">int loaderLoadAndExec(const char *name, int 
privilege, int</font><font face="Courier New"> argc, char *argv[], int block)</font></p>
<blockquote>
  <p><font face="Times New Roman">This function is just for convenience, and is 
  an amalgamation of the loader functions </font><font face="Courier New">
  loaderLoadProgram()</font><font face="Times New Roman"> and&nbsp; </font>
  <font face="Courier New">loaderExecProgram()</font><font face="Times New Roman">.</font></p>
</blockquote>
<p>&nbsp;</p>
<p><b><font size="4"><a name="realtime"></a>Real-time clock functions</font></b></p>
<p><font face="Courier New">int rtcReadSeconds(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the current seconds value.</font></p>
</blockquote>
<p><font face="Courier New">int rtcReadMinutes(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the current minutes value.</font></p>
</blockquote>
<p><font face="Courier New">int rtcReadHours(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the current hours value.</font></p>
</blockquote>
<p><font face="Courier New">int rtcReadDayOfWeek(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the current day of the week value.</font></p>
</blockquote>
<p><font face="Courier New">int rtcReadDayOfMonth(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the current day of the month value.</font></p>
</blockquote>
<p><font face="Courier New">int rtcReadMonth(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the current month value.</font></p>
</blockquote>
<p><font face="Courier New">int rtcReadYear(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the current year value.</font></p>
</blockquote>
<p><font face="Courier New">unsigned int rtcUptimeSeconds(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the number of seconds the system has been 
  running.</font></p>
</blockquote>
<p><font face="Courier New">int rtcDateTime(struct tm *time)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the current data and time as a tm data 
  structure in 'time'.</font></p>
</blockquote>
<p>&nbsp;</p>
<p><b><font size="4"><a name="random"></a>Random number functions</font></b></p>
<p><font face="Courier New">unsigned int randomUnformatted(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get an unformatted random unsigned number.&nbsp; 
  Just any unsigned number.</font></p>
</blockquote>
<p><font face="Courier New">unsigned int randomFormatted(unsigned int start, 
unsigned int end)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get a random unsigned number between the start 
  value 'start' and the end value 'end', inclusive.</font></p>
</blockquote>
<p><font face="Courier New">unsigned int randomSeededUnformatted(unsigned int 
seed)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get an unformatted random unsigned number, 
  using the random seed 'seed' instead of the kernel's default random seed.</font></p>
</blockquote>
<p><font face="Courier New">unsigned int randomSeededFormatted(unsigned int 
seed, unsigned int start, unsigned int end)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get a random unsigned number between the start 
  value 'start' and the end value 'end', inclusive, using the random seed 'seed' 
  instead of the kernel's default random seed.</font></p>
</blockquote>
<p>&nbsp;</p>
<p><b><font size="4"><a name="environment"></a>Environment functions</font></b></p>
<p><font face="Courier New">int environmentGet(const char *var, char *buf, 
unsigned int bufsz)</font></p>
<blockquote>
  <p>Get the value of the environment variable named 'var', and put it into the 
  buffer 'buf' of size 'bufsz' if successful.</p>
</blockquote>
<p><font face="Courier New">int environmentSet(const char *var, const char *val)</font></p>
<blockquote>
  <p><font face="Times New Roman">Set the environment variable 'var' to the 
  value 'val', overwriting any old value that might have been previously set.</font></p>
</blockquote>
<p><font face="Courier New">int environmentUnset(const char *var)</font></p>
<blockquote>
  <p>Delete the environment variable 'var'.</p>
</blockquote>
<p><font face="Courier New">void environmentDump(void)</font></p>
<blockquote>
  <p>Print a listing of all the currently set environment variables in the 
  calling process' environment space to the current text output stream.</p>
</blockquote>
<p>&nbsp;</p>
<p><b><font size="4"><a name="graphics"></a>Raw graphics functions</font></b></p>
<p><font face="Courier New">int graphicsAreEnabled(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Returns 1 if the kernel is operating in 
  graphics mode.</font></p>
</blockquote>
<p><font face="Courier New">unsigned graphicGetScreenWidth(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Returns the width of the graphics screen.</font></p>
</blockquote>
<p><font face="Courier New">unsigned graphicGetScreenHeight(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Returns the height of the graphics screen.</font></p>
</blockquote>
<p><font face="Courier New">unsigned graphicCalculateAreaBytes(unsigned width, 
unsigned height)</font></p>
<blockquote>
  <p><font face="Times New Roman">Returns the number of bytes required to 
  allocate a graphic buffer of width 'width' and height 'height'.&nbsp; This is 
  a function of the screen resolution, etc.</font></p>
</blockquote>
<p><font face="Courier New">int graphicClearScreen(color *background)</font></p>
<blockquote>
  <p><font face="Times New Roman">Clear the screen to the background color 
  'background'.</font></p>
</blockquote>
<p><font face="Courier New">int graphicDrawPixel(objectKey buffer, color 
*foreground, drawMode</font><font face="Courier New"> mode, int xCoord, int 
yCoord)</font></p>
<blockquote>
  <p><font face="Times New Roman">Draw a single pixel into the graphic buffer 
  'buffer', using the color 'foreground', the drawing mode 'drawMode' (for 
  example, 'draw_normal' or 'draw_xor'), the X coordinate 'xCoord' and the Y 
  coordinate 'yCoord'.&nbsp; If 'buffer' is NULL, draw directly onto the screen.</font></p>
</blockquote>
<p><font face="Courier New">int graphicDrawLine(objectKey buffer, color 
*foreground, drawMode</font><font face="Courier New"> mode, int startX, int 
startY, int</font><font face="Courier New"> endX, int endY)</font></p>
<blockquote>
  <p><font face="Times New Roman">Draw a line into the graphic buffer 'buffer', 
  using the color 'foreground', the drawing mode 'drawMode' (for example, 'draw_normal' 
  or 'draw_xor'), the starting X coordinate 'startX', the starting Y coordinate 
  'startY', the ending X coordinate 'endX' and the ending Y coordinate 'endY'.&nbsp; 
  At the time of writing, only horizontal and vertical lines are supported by 
  the linear framebuffer graphic driver.&nbsp; If 'buffer' is NULL, draw 
  directly onto the screen.</font></p>
</blockquote>
<p><font face="Courier New">int graphicDrawRect(objectKey buffer, color 
*foreground, drawMode</font><font face="Courier New"> mode, int xCoord, int 
yCoord, unsigned width, unsigned height, unsigned thickness, int fill)</font></p>
<blockquote>
  <p><font face="Times New Roman">Draw a rectangle into the graphic buffer 
  'buffer', using the color 'foreground', the drawing mode 'drawMode' (for 
  example, 'draw_normal' or 'draw_xor'), the starting X coordinate 'xCoord', the 
  starting Y coordinate 'yCoord', the width 'width', the height 'height', the 
  line thickness 'thickness' and the fill value 'fill'.&nbsp; Non-zero fill 
  value means fill the rectangle.&nbsp;&nbsp; If 'buffer' is NULL, draw directly 
  onto the screen.</font></p>
</blockquote>
<p><font face="Courier New">int graphicDrawOval(objectKey buffer, color 
*foreground, drawMode</font><font face="Courier New"> mode, int xCoord, int 
yCoord, unsigned width, unsigned height, unsigned thickness, int fill)</font></p>
<blockquote>
  <p><font face="Times New Roman">Draw an oval (circle, whatever) into the 
  graphic buffer 'buffer', using the color 'foreground', the drawing mode 'drawMode' 
  (for example, 'draw_normal' or 'draw_xor'), the starting X coordinate 'xCoord', 
  the starting Y coordinate 'yCoord', the width 'width', the height 'height', 
  the line thickness 'thickness' and the fill value 'fill'.&nbsp; Non-zero fill 
  value means fill the oval.&nbsp;&nbsp; If 'buffer' is NULL, draw directly onto 
  the screen.&nbsp; Currently not supported by the linear framebuffer graphic 
  driver.</font></p>
</blockquote>
<p><font face="Courier New">int graphicDrawImage(objectKey buffer, image *drawImage, 
int</font><font face="Courier New"> xCoord, int yCoord)</font></p>
<blockquote>
  <p><font face="Times New Roman">Draw the image 'drawImage' into the graphic 
  buffer 'buffer', using the starting X coordinate 'xCoord' and the starting Y 
  coordinate 'yCoord'.&nbsp;&nbsp; If 'buffer' is NULL, draw directly onto the 
  screen.</font></p>
</blockquote>
<p><font face="Courier New">int graphicGetImage(objectKey buffer, image *getImage, 
int</font><font face="Courier New"> xCoord, int yCoord, unsigned width, unsigned 
height)</font></p>
<blockquote>
  <p><font face="Times New Roman">Grab a new image 'getImage' from the graphic 
  buffer 'buffer', using the starting X coordinate 'xCoord', the starting Y 
  coordinate 'yCoord', the width 'width' and the height 'height'.&nbsp;&nbsp; If 
  'buffer' is NULL, grab the image directly from the screen.</font></p>
</blockquote>
<p><font face="Courier New">int graphicDrawText(objectKey buffer, color 
*foreground, objectKey</font><font face="Courier New"> font, const char *text, 
drawMode</font><font face="Courier New"> mode, int xCoord, int yCoord)</font></p>
<blockquote>
  <p><font face="Times New Roman">Draw the text string 'text' into the graphic 
  buffer 'buffer', using the color 'foreground', the font 'font', the drawing 
  mode 'drawMode' (for example, 'draw_normal' or 'draw_xor'), the starting X 
  coordinate 'xCoord', the starting Y coordinate 'yCoord'.&nbsp;&nbsp; If 
  'buffer' is NULL, draw directly onto the screen.&nbsp; If 'font' is NULL, use 
  the default font.</font></p>
</blockquote>
<p><font face="Courier New">int graphicCopyArea(objectKey buffer, int xCoord1, 
int yCoord1, unsigned width, unsigned height, int</font><font face="Courier New"> 
xCoord2, int yCoord2)</font></p>
<blockquote>
  <p><font face="Times New Roman">Within the graphic buffer 'buffer', copy the 
  area bounded by ('xCoord1', 'yCoord1'), width 'width' and height 'height' to 
  the starting X coordinate 'xCoord2' and the starting Y coordinate 'yCoord2'.&nbsp; 
  If 'buffer' is NULL, copy directly to and from the screen.</font></p>
</blockquote>
<p><font face="Courier New">int graphicClearArea(objectKey buffer, color 
*background, int</font><font face="Courier New"> xCoord, int yCoord, unsigned 
width, unsigned height)</font></p>
<blockquote>
  <p><font face="Times New Roman">Clear the area of the graphic buffer 'buffer' 
  using the background color 'background', using the starting X coordinate 'xCoord', 
  the starting Y coordinate 'yCoord', the width 'width' and the height 'height'.&nbsp; 
  If 'buffer' is NULL, clear the area directly on the screen.</font></p>
</blockquote>
<p><font face="Courier New">int graphicRenderBuffer(objectKey buffer, int drawX, 
int</font><font face="Courier New"> drawY, int clipX, int clipY, unsigned 
clipWidth, unsigned clipHeight)</font></p>
<blockquote>
  <p><font face="Times New Roman">Draw the clip of the buffer 'buffer' onto the 
  screen.&nbsp; Draw it on the screen at starting X coordinate 'drawX' and 
  starting Y coordinate 'drawY'.&nbsp; The buffer clip is bounded by the 
  starting X coordinate 'clipX', the starting Y coordinate 'clipY', the width 'clipWidth' 
  and the height 'clipHeight'.&nbsp; It is not legal for 'buffer' to be NULL in 
  this case.</font></p>
</blockquote>
<p>&nbsp;</p>
<p><b><font size="4"><a name="window"></a>Window manager functions</font></b></p>
<p><font face="Courier New">int windowManagerStart(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Starts the window manager.&nbsp; Not useful 
  for most external programa.</font></p>
</blockquote>
<p><font face="Courier New">int windowManagerLogin(int userId)</font></p>
<blockquote>
  <p><font face="Times New Roman">Log the user specified by the user ID 'userId' 
  into the window manager.</font></p>
</blockquote>
<p><font face="Courier New">int windowManagerLogout(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Log the current user out of the window 
  manager.</font></p>
</blockquote>
<p><font face="Courier New">objectKey windowManagerNewWindow(int processId, char 
*title, int</font><font face="Courier New"> xCoord, int yCoord, int</font><font face="Courier New"> 
width, int height)</font></p>
<blockquote>
  <p><font face="Times New Roman">Create a new window, owned by the process 
  referenced by the process ID 'processId'.&nbsp; Set the window title to 
  'title', and place it initially at the specified coordinates with the given 
  width and height.&nbsp; Returns an object key to referenc the window, needed 
  by most other window manager functions below.</font></p>
</blockquote>
<p><font face="Courier New">int windowManagerDestroyWindow(objectKey window)</font></p>
<blockquote>
  <p><font face="Times New Roman">Destroy the window referenced by the object 
  key 'wndow'</font></p>
</blockquote>
<p><font face="Courier New">int windowManagerUpdateBuffer(void *buffer, int 
xCoord, int</font><font face="Courier New"> yCoord, unsigned width, unsigned 
height)</font></p>
<blockquote>
  <p><font face="Times New Roman">Tells the window manager to redraw the visible 
  portions of the window's graphic buffer 'buffer' and the given clip 
  coordinates/size.</font></p>
</blockquote>
<p><font face="Courier New">int windowSetTitle(objectKey window, const char 
*title)</font></p>
<blockquote>
  <p><font face="Times New Roman">Set the new title of window 'window' to be 
  'title'.</font></p>
</blockquote>
<p><font face="Courier New">int windowGetSize(objectKey window, unsigned *width, 
unsigned *height)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the size of the window 'window', and put 
  the results in 'width' and 'height'.</font></p>
</blockquote>
<p><font face="Courier New">int windowSetSize(objectKey window, unsigned width, 
unsigned height)</font></p>
<blockquote>
  <p><font face="Courier New">&nbsp;&nbsp;&nbsp; </font>
  <font face="Times New Roman">Resize the window 'window' to the width 'width' 
  and the height 'height'.</font></p>
</blockquote>
<p><font face="Courier New">int windowAutoSize(objectKey window)</font></p>
<blockquote>
  <p><font face="Times New Roman">Automatically set the size of window 'window' 
  based on the sizes and locations of the window components it contains.</font></p>
</blockquote>
<p><font face="Courier New">int windowGetLocation(objectKey window, int *xCoord, 
int *yCoord)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the current screen location of the window 
  'window' and put it into the coordinate variables 'xCoord' and 'yCoord'.</font></p>
</blockquote>
<p><font face="Courier New">int windowSetLocation(objectKey window, int xCoord, 
int&nbsp; yCoord)</font></p>
<blockquote>
  <p><font face="Times New Roman">Set the screen location of the window 'window' 
  using the coordinate variables 'xCoord' and 'yCoord'.</font></p>
</blockquote>
<p><font face="Courier New">int windowSetHasBorder(objectKey window, int 
trueFalse)</font></p>
<blockquote>
  <p><font face="Times New Roman">Tells the window manager whether to draw a 
  border around the window 'window'.&nbsp; 'trueFalse' being non-zero means draw 
  a border.&nbsp; Windows have borders by default.</font></p>
</blockquote>
<p><font face="Courier New">int windowSetHasTitleBar(objectKey window, int 
trueFalse)</font></p>
<blockquote>
  <p><font face="Times New Roman">Tells the window manager whether to draw a 
  title bar on the window 'window'.&nbsp; 'trueFalse' being non-zero means draw 
  a title bar.&nbsp; Windows have title bars by default.</font></p>
</blockquote>
<p><font face="Courier New">int windowSetMovable(objectKey window, int trueFalse)</font></p>
<blockquote>
  <p><font face="Times New Roman">Tells the window manager whether the window 
  'window' should be movable by the user (i.e. clicking and dragging it).&nbsp; 
  'trueFalse' being non-zero means the window is movable.&nbsp; Windows are 
  movable by default.</font></p>
</blockquote>
<p><font face="Courier New">int windowSetHasCloseButton(objectKey window, int 
trueFalse)</font></p>
<blockquote>
  <p><font face="Times New Roman">Tells the window manager whether to draw a 
  close button on the title bar of the window 'window'.&nbsp; 'trueFalse' being 
  non-zero means draw a close button.&nbsp; Windows have close buttons by 
  default, as long as they have a title bar.&nbsp; If there is no title bar, 
  then this function has no effect.</font></p>
</blockquote>
<p><font face="Courier New">int windowLayout(objectKey window)</font></p>
<blockquote>
  <p><font face="Times New Roman">Do the layout of the window 'window' after all 
  the components have been added.&nbsp; You really should call this function 
  before displaying a window, or else all the window components will be squished 
  together in the top corner of the window, ignoring any grid coordinates you 
  have set in the 'componentParameters' structure of an </font>
  <font face="Courier New">windowAdd*Component()</font><font face="Times New Roman"> 
  call.&nbsp; If you are going to use </font><font face="Courier New">
  windowAutoSize()</font><font face="Times New Roman"> to size the window, you 
  should do so after this call.</font></p>
</blockquote>
<p><font face="Courier New">int windowSetVisible(objectKey window, int visible)</font></p>
<blockquote>
  <p><font face="Times New Roman">Tell the window manager whether to make the 
  window 'window' visible or not.&nbsp; Non-zero 'visible' means make the window 
  visible.&nbsp; When windows are created, they are not visible by default so 
  you can add components, do layout, set the size, etc.</font></p>
</blockquote>
<p><font face="Courier New">int windowAddComponent(objectKey window, objectKey 
component, componentParameters</font><font face="Courier New"> *params)</font></p>
<blockquote>
  <p><font face="Times New Roman">Add a window component 'component' to the 
  window 'window' using the parameters specified in the componentParameters 
  structure 'params'.&nbsp; You should probably use the </font>
  <font face="Courier New">windowAddClientComponent()</font><font face="Times New Roman"> 
  function instead, as this function disregards things like the sizes of window 
  title bars and borders, so your window might look funny unless you know what 
  you're doing.</font></p>
</blockquote>
<p><font face="Courier New">int windowAddClientComponent(objectKey window, 
objectKey</font><font face="Courier New"> component, componentParameters</font><font face="Courier New"> 
*params)</font></p>
<blockquote>
  <p><font face="Times New Roman">Add a window component 'component' to the 
  client area of the window 'window' using the parameters specified in the 
  componentParameters structure 'params'.&nbsp; This function is the normal way 
  to add any component to a window.</font></p>
</blockquote>
<p><font face="Courier New">unsigned windowComponentGetWidth(objectKey 
component)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the pixel width of the window component 
  'component'.&nbsp; Useful if you are doing your window layout manually.</font></p>
</blockquote>
<p><font face="Courier New">unsigned windowComponentGetHeight(objectKey 
component)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the pixel height of the window component 
  'component'.&nbsp; Useful if you are doing your window layout manually.</font></p>
</blockquote>
<p><font face="Courier New">void windowManagerRedrawArea(int xCoord, int yCoord, 
unsigned width, unsigned height)</font></p>
<blockquote>
  <p><font face="Times New Roman">Tells the window manager to redraw whatever is 
  supposed to be in the screen area bounded by the supplied coordinates.&nbsp; 
  This might be useful if you were drawing non-window-based things on the screen 
  and you wanted them to go away later.</font></p>
</blockquote>
<p><font face="Courier New">void windowManagerProcessMouseEvent(objectKey 
mouseStatus)</font></p>
<blockquote>
  <p><font face="Times New Roman">Called by the mouse functions to tell the 
  window manager that the mouse status has changed.&nbsp; Might be able to do 
  unusual things with this function if you're not a mouse driver, but I'm not 
  going to suggest any.</font></p>
</blockquote>
<p><font face="Courier New">int windowManagerTileBackground(const char *file)</font></p>
<blockquote>
  <p><font face="Times New Roman">Load the image file specified by the pathname 
  'file', and if successful, tile the image on the background root window.</font></p>
</blockquote>
<p><font face="Courier New">int windowManagerCenterBackground(const char *file)</font></p>
<blockquote>
  <p><font face="Times New Roman">Load the image file specified by the pathname 
  'file', and if successful, center the image on the background root window.</font></p>
</blockquote>
<p><font face="Courier New">int windowManagerScreenShot(image *saveImage)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get an image representation of the entire 
  screen in the image data structure 'saveImage'.&nbsp; Note that it is not 
  necessary to allocate memory for the data pointer of the image structure 
  beforehand, as this is done automatically.&nbsp; You should, however, 
  deallocate the data field of the image structure when you are finished with 
  it.</font></p>
</blockquote>
<p><font face="Courier New">int windowManagerSaveScreenShot(const char 
*filename)</font></p>
<blockquote>
  <p><font face="Times New Roman">Save a screenshot of the entire screen to the 
  file specified by the pathname 'filename'.</font></p>
</blockquote>
<p><font face="Courier New">int windowManagerSetTextOutput(objectKey key) </font>
</p>
<blockquote>
  <p><font face="Times New Roman">Set the text output (and input) of the calling 
  process to the object key of some window component, such as a TextArea or 
  TextField component.&nbsp; You'll need to use this if you want to output text 
  to one of these components or receive input from one.</font></p>
</blockquote>
<p><font face="Courier New">objectKey windowNewButtonComponent(objectKey window, 
unsigned width, unsigned height, const char *label, image *buttonImage)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get a new ButtonComponent to be placed in the 
  window 'window', using the supplied width and height, and with the (optional) 
  label 'label', or the (optional) image 'buttonImage'.&nbsp; Either 'label' or 
  'buttonImage' can be non-NULL, but not both.&nbsp; For the moment, there is no 
  mechanism for a callback function to a user space program, so a button 
  component is not currently very useful to user programs since it won't be able 
  to trigger any action.&nbsp; After creating any window component you should 
  add it to the window by calling the </font><font face="Courier New">
  windowAddClientComponent()</font><font face="Times New Roman">&nbsp; function.</font></p>
</blockquote>
<p><font face="Courier New">objectKey windowNewIconComponent(objectKey window, 
image *iconImage, const char *label, const char *command)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get a new IconComponent to be placed in the 
  window 'window', using the image data structure 'iconImage' and the label 
  'label'.&nbsp; If you want the icon to execute a command when clicked, you 
  should specify it in 'command'.&nbsp; After creating any window component you 
  should add it to the window by calling the </font><font face="Courier New">
  windowAddClientComponent()</font><font face="Times New Roman">&nbsp; function.</font></p>
</blockquote>
<p><font face="Courier New">objectKey windowNewImageComponent(objectKey window, 
image *baseImage)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get a new ImageComponent to be placed in the 
  window 'window', using the image data structure 'baseImage' .&nbsp; After 
  creating any window component you should add it to the window by calling the
  </font><font face="Courier New">windowAddClientComponent()</font><font face="Times New Roman">&nbsp; 
  function.</font></p>
</blockquote>
<p><font face="Courier New">objectKey windowNewTextAreaComponent(objectKey 
window, int</font><font face="Courier New"> columns, int rows, objectKey font)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get a new TextAreaComponent to be placed in 
  the window 'window', using the number of columns 'columns', the number of rows 
  'rows', and the font 'font'.&nbsp; If 'font' is NULL, that means use the 
  default font.&nbsp; After creating any window component you should add it to 
  the window by calling the </font><font face="Courier New">
  windowAddClientComponent()</font><font face="Times New Roman">&nbsp; function.</font></p>
</blockquote>
<p><font face="Courier New">objectKey windowNewTextFieldComponent(objectKey 
window, int</font><font face="Courier New"> columns, objectKey font)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get a new TextFieldComponent to be placed in 
  the window 'window', using the number of columns 'columns' and the font 
  'font'.&nbsp; TextFieldComponents are essentially 1-line TextAreaComponents.&nbsp; 
  If 'font' is NULL, that means use the default font.&nbsp; After creating any 
  window component you should add it to the window by calling the </font>
  <font face="Courier New">windowAddClientComponent()</font><font face="Times New Roman">&nbsp; 
  function.</font></p>
</blockquote>
<p><font face="Courier New">objectKey windowNewTextLabelComponent(objectKey 
window, objectKey</font><font face="Courier New"> font, const char *text)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get a new TextLabelComponent to be placed in 
  the window 'window', using the text string 'text' and the font 'font'.&nbsp; 
  If 'font' is NULL, that means use the default font.&nbsp; After creating any 
  window component you should add it to the window by calling the </font>
  <font face="Courier New">windowAddClientComponent()</font><font face="Times New Roman">&nbsp; 
  function.</font></p>
</blockquote>
<p><font face="Courier New">objectKey windowNewTitleBarComponent(objectKey 
window, unsigned width, unsigned height)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get a new TitleBarComponent to be placed in 
  the window 'window', using the width 'width' and the height 'height'.&nbsp; At 
  the time of writing, this is not necessarily useful to external programs as 
  window title bars are created automatically if applicable, and using this 
  function might produce surprising results.&nbsp; After creating any window 
  component you should add it to the window by calling the </font>
  <font face="Courier New">windowAddClientComponent()</font><font face="Times New Roman">&nbsp; 
  function.</font></p>
</blockquote>
<p>&nbsp;</p>
<p><b><font size="4"><a name="misc"></a>Miscellaneous functions</font></b></p>
<p><font face="Courier New">int fontGetDefault(objectKey *pointer)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get an object key in 'pointer' to refer to the 
  current default font.</font></p>
</blockquote>
<p><font face="Courier New">int fontSetDefault(const char *name)</font></p>
<blockquote>
  <p><font face="Times New Roman">Set the default font for the system to the 
  font with the name 'name'.&nbsp; The font must previously have been loaded by 
  the system, for example using the </font><font face="Courier New">fontLoad()</font><font face="Times New Roman">&nbsp; 
  function.</font></p>
</blockquote>
<p><font face="Courier New">int fontLoad(const char* filename, const char *fontname, 
objectKey</font><font face="Courier New"> *pointer)</font></p>
<blockquote>
  <p><font face="Times New Roman">Load the font from the font file 'filename', 
  give it the font name 'fontname' for future reference, and return an object 
  key for the font in 'pointer' if successful.</font></p>
</blockquote>
<p><font face="Courier New">unsigned fontGetPrintedWidth(objectKey font, const 
char *string)</font></p>
<blockquote>
  <p><font face="Times New Roman">Given the supplied string, return the screen 
  width that the text will consume given the font 'font'.&nbsp; Useful for 
  placing text when using a variable-width font, but not very useful otherwise.</font></p>
</blockquote>
<p><font face="Courier New">unsigned fontGetHeight(objectKey font)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the height of characters when using the 
  font 'font'.</font></p>
</blockquote>
<p><font face="Courier New">int imageLoadBmp(const char *filename, image *loadImage)</font></p>
<blockquote>
  <p><font face="Times New Roman">Try to load the bitmap image file 'filename', 
  and if successful, save the data in the image data structure 'loadImage'.</font></p>
</blockquote>
<p><font face="Courier New">int imageSaveBmp(const char *filename, image *saveImage)</font></p>
<blockquote>
  <p><font face="Times New Roman">Save the image data structure 'saveImage' as a 
  bitmap, to the file 'fileName'.</font></p>
</blockquote>
<p><font face="Courier New">int shutdown(int type, int nice)</font></p>
<blockquote>
  <p><font face="Times New Roman">Shutdown or reboot the system, according to 
  the value ('shutdown' or 'reboot') 'type'.&nbsp; If 'nice' is zero, the 
  shutdown will be orderly and will abort if serious errors are detected.&nbsp; 
  If 'nice' is non-zero, the system will go down like a kamikaze regardless of 
  errors.</font></p>
</blockquote>
<p><font face="Courier New">const char *version(void)</font></p>
<blockquote>
  <p><font face="Times New Roman">Get the kernel's version string.</font></p>
</blockquote>

<p>&nbsp;</p>

<p align="left"></p>

<!--msnavigation--></td><td valign="top" width="24"></td><td valign="top" width="1%">
<div align="left">
  <table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td>
        &nbsp;
        <script type="text/javascript"><!--
          google_ad_client = "pub-2784580927617241";
          google_ad_width = 160;
          google_ad_height = 600;
          google_ad_format = "160x600_as";
          google_ad_type = "text";
          google_ad_channel ="";
          google_color_border = "336699";
          google_color_bg = "FFFFFF";
          google_color_link = "0000FF";
          google_color_url = "008000";
          google_color_text = "000000";
          //-->
        </script>
        <script type="text/javascript"
          src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
        </script>
      </td>
    </tr>
  </table>
</div>
</td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td>

<blockquote>
  <blockquote>
    <p align="right"><font color="#FFFFFF"><a href="../index.html">
    <img
    src="../img/nav_buttons/home.gif" alt="Home" border="0"
    align="middle" width="53" height="25"></a>&nbsp;&nbsp; <a href="../about/index.html">
    <img src="../img/nav_buttons/about.gif"
    alt="About" border="0" align="middle" width="60" height="25"></a>&nbsp;&nbsp;
    <a href="../about/news.html">
    <img border="0" src="../img/nav_buttons/news.gif" align="middle" alt="News" width="49" height="16"></a>&nbsp;&nbsp; </font>
    <a href="../about/screenshots.html">
    <img border="0" src="../img/nav_buttons/screenshots.gif" align="middle" alt="Screenshots" width="105" height="22"></a>&nbsp;&nbsp; <font color="#FFFFFF"> <a href="../download/index.html">
    <img
    src="../img/nav_buttons/download.gif" alt="Download"
    border="0" align="middle" width="95" height="25"></a>&nbsp; </font>&nbsp;<a href="index.html"><img
    src="../img/nav_buttons/developers.gif" alt="Developers"
    border="0" align="middle" width="97" height="29"></a>&nbsp;&nbsp; <a href="../osdev/index.html">
    <img
    src="../img/nav_buttons/osdev.gif" border="0" align="middle" alt="OS Development" width="64" height="25"></a>&nbsp;&nbsp; <a href="../search.html">
    <img
    src="../img/nav_buttons/search.gif" alt="Search" align="middle"
    border="0" width="63" height="24"></a><font face="Times New Roman" color="#FFFFFF"><br>
    This site is copyright  1999-2005, <a href="mailto:andy@visopsys.org">J.
    Andrew (Andy) McLaughlin</a><br>
    Visopsys and Visopsys.org are trademarks of J. Andrew McLaughlin<br>
    Last updated on
    November 29, 2005</font></p>
  </blockquote>
</blockquote>

<p>&nbsp;</p>

</td></tr><!--msnavigation--></table></body>
</html>