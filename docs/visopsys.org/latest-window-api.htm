<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Visopsys &#126; Window Library</title>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=iso-8859-1" />
    <link rel="stylesheet" href="blade_packs/system_razorSiteSearch/css/sitesearch.css" type="text/css" media="screen" />    <link rel="stylesheet" type="text/css" href="blade_packs/theme_ClearBlue/ClearBlue_css.css" />
    <!-- WIN IE Style Sheets -->
<!--[if IE]>
  <![if gte IE 5.5]>
   <![if gte IE 7]><link rel="stylesheet" 
	type="text/css" media="screen,projection" 
	href="ie.css" />
	<![endif]>
   <![if lt IE 7]><link rel="stylesheet" 
	type="text/css" media="screen,projection" 
	href="ie.css" />
	<![endif]>
  <![endif]>
  <![if lt IE 5.5]>
   <link rel="stylesheet"
	type="text/css" media="screen,projection" 
	href="ie.css" />
    <![endif]>
<![endif]-->
        <link rel="shortcut icon" href="favicon.ico" />
</head>
<body>
<div id="wrap">
  <div id="wrap2">
    <div id="header">

<h1 id="logo"><img src="visopsys-logo1.png" width="300px" height="85px" /></h1>

      <!--<h1 id="logo">Visopsys</h1>
            <div id="slogan">Visual Operating System</div>-->

	    <div id='searchBoxHeader'><div><form action='http://visopsys.org/razor-SiteSearch.htm' method='post'><input class='searchText' type='text' name='siteSearch' /><input class='searchButton' type='submit' value='Search' /></form></div></div>    </div>
    <div id="nav">
      <div id="nbar">
            <ul class="first"><li><a href='index.html'>Home</a></li><li><a href='about.htm'>About</a></li><li><a href='news.htm'>News</a></li><li><a href='screenshots.htm'>Screenshots</a></li><li><a href='downloads.htm'>Downloads</a></li><li><a href='forums/index.php'>Forum</a></li><li><a href='developers.htm'>Developers</a></li><li><a href='os-dev.htm'>OS Dev</a></li></ul>	             </div>
    </div>
    <div id="content-wrap">
      <div id="sidebar">
      <div id="right_sidebar">
          <div id="side_sky_ad">
          	<!-- Sidebar Sky Scraper Ad -->
            <!-- 160 x 600 Google ad code -->
                                <script type="text/javascript"><!--
					google_ad_client = "ca-pub-2784580927617241";
					/* orig */
					google_ad_slot = "8342665437";
					google_ad_width = 160;
					google_ad_height = 600;
					//-->
				  </script>
				  <script type="text/javascript"
					src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
				  </script>
          </div>
        </div>
      <!--<div id="left_sidebar">
                                Edit this sidebar with the Filemanager in<br/>
root/blade_packs/ theme_ClearBlue/ ClearBlue_xhtml.php
          </div>-->
      </div>
      <div id="content">
                <p align="left" style="color: rgb(0, 0, 0); font-family: arial; font-size: medium;">
	<b><font face="Arial" size="4">Developers</font></b></p>
<div align="center" style="color: rgb(0, 0, 0); font-family: arial; font-size: medium;">
	<center>
		<table border="0" bordercolor="#111111" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" width="100%">
			<tbody>
				<tr>
					<td>
						<b>THE VISOPSYS WINDOW LIBRARY (Version 0.7)</b><br />
						<p>
							The window library is a set of functions to aid GUI development on the Visopsys platform. At present the list of functions is small, but it does provide very useful functionality. This includes an interface for registering window event callbacks for GUI components, and a &#39;run&#39; function to poll for such events.</p>
						<p>
							The functions are defined in the header file &lt;sys/window.h&gt; and the code is contained in libwindow.a (link with &#39;-lwindow&#39;).<br />
							&nbsp;</p>
						<p>
							<font face="Courier New">objectKey windowNewBannerDialog(objectKey parentWindow, const char *title, const char *message)</font></p>
						<blockquote>
							<p>
								Create a &#39;banner&#39; dialog box, with the parent window &#39;parentWindow&#39;, and the given titlebar text and main message. This is the very simplest kind of dialog; it just contains the supplied message with no acknowledgement mechanism for the user. If &#39;parentWindow&#39; is NULL, the dialog box is actually created as an independent window that looks the same as a dialog. This is a non-blocking call that returns the object key of the dialog window. The caller must destroy the window when finished with it.</p>
						</blockquote>
						<p>
							<font face="Courier New">void windowCenterDialog(objectKey parentWindow, objectKey dialogWindow)</font></p>
						<blockquote>
							<p>
								Center a dialog window. The first object key is the parent window, and the second is the dialog window. This function can be used to center a regular window on the screen if the first objectKey argument is NULL.</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowNewChoiceDialog(objectKey parentWindow, const char *title, const char *message, char *choiceStrings[], int numChoices, int defaultChoice)</font></p>
						<blockquote>
							<p>
								Create a &#39;choice&#39; dialog box, with the parent window &#39;parentWindow&#39;, the given titlebar text and main message, and &#39;numChoices&#39; choices, as specified by the &#39;choiceStrings&#39;. &#39;default&#39; is the default focussed selection. The dialog will have a button for each choice. If the user chooses one of the choices, the function returns the 0-based index of the choice. Otherwise it returns negative. If &#39;parentWindow&#39; is NULL, the dialog box is actually created as an independent window that looks the same as a dialog. This is a blocking call that returns when the user closes the dialog window (i.e. the dialog is &#39;modal&#39;).</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowNewColorDialog(objectKey parentWindow, color *pickedColor)</font></p>
						<blockquote>
							<p>
								Create an &#39;color chooser&#39; dialog box, with the parent window &#39;parentWindow&#39;, and a pointer to the color structure &#39;pickedColor&#39;. Currently the window consists of red/green/blue sliders and a canvas displaying the current color. The initial color displayed will be whatever is supplied in &#39;pickedColor&#39;. If &#39;parentWindow&#39; is NULL, the dialog box is actually created as an independent window that looks the same as a dialog. This is a blocking call that returns when the user closes the dialog window (i.e. the dialog is &#39;modal&#39;).</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowNewFileDialog(objectKey parentWindow, const char *title, const char *message, const char *startDir, char *fileName, unsigned maxLength, int thumb)</font></p>
						<blockquote>
							<p>
								Create a &#39;file&#39; dialog box, with the parent window &#39;parentWindow&#39;, and the given titlebar text and main message. If &#39;startDir&#39; is a non-NULL directory name, the dialog will initially display the contents of that directory. If &#39;fileName&#39; contains data (i.e. the string&#39;s first character is non-NULL), the file name field of the dialog will contain that string. If &#39;thumb&#39; is non-zero, an area will display image thumbnails when image files are clicked. The dialog will have a file selection area, a file name field, an &#39;OK&#39; button and a &#39;CANCEL&#39; button. If the user presses OK or ENTER, the function returns the value 1 and copies the file name into the fileName buffer. Otherwise it returns 0 and puts a NULL string into fileName. If &#39;parentWindow&#39; is NULL, the dialog box is actually created as an independent window that looks the same as a dialog. This is a blocking call that returns when the user closes the dialog window (i.e. the dialog is &#39;modal&#39;).</p>
						</blockquote>
						<p>
							<font face="Courier New">windowFileList *windowNewFileList(objectKey parent, windowListType type, int rows, int columns, const char *directory, int flags, void *callback, componentParameters *params)</font></p>
						<blockquote>
							<p>
								Create a new file list widget with the parent window &#39;parent&#39;, the window list type &#39;type&#39; (windowlist_textonly or windowlist_icononly is currently supported), of height &#39;rows&#39; and width &#39;columns&#39;, the name of the starting location &#39;directory&#39;, flags (such as WINFILEBROWSE_CAN_CD or WINFILEBROWSE_CAN_DEL -- see sys/window.h), a function &#39;callback&#39; for when the status changes, and component parameters &#39;params&#39;.</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowClearEventHandlers(void)</font></p>
						<blockquote>
							<p>
								Remove all the callback event handlers registered with the windowRegisterEventHandler() function.</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowRegisterEventHandler(objectKey key, void (*function)(objectKey, windowEvent *))</font></p>
						<blockquote>
							<p>
								Register a callback function as an event handler for the GUI object &#39;key&#39;. The GUI object can be a window component, or a window for example. GUI components are typically the target of mouse click or key press events, whereas windows typically receive &#39;close window&#39; events. For example, if you create a button component in a window, you should call windowRegisterEventHandler() to receive a callback when the button is pushed by a user. You can use the same callback function for all your objects if you wish -- the objectKey of the target component can always be found in the windowEvent passed to your callback function. It is necessary to use one of the &#39;run&#39; functions, below, such as windowGuiRun() or windowGuiThread() in order to receive the callbacks.</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowClearEventHandler(objectKey key)</font></p>
						<blockquote>
							<p>
								Remove a callback event handler registered with the windowRegisterEventHandler() function.</p>
						</blockquote>
						<p>
							<font face="Courier New">void windowGuiRun(void)</font></p>
						<blockquote>
							<p>
								Run the GUI windowEvent polling as a blocking call. In other words, use this function when your program has completed its setup code, and simply needs to watch for GUI events such as mouse clicks, key presses, and window closures. If your program needs to do other processing (independently of windowEvents) you should use the windowGuiThread() function instead.</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowGuiThread(void)</font></p>
						<blockquote>
							<p>
								Run the GUI windowEvent polling as a non-blocking call. In other words, this function will launch a separate thread to monitor for GUI events and return control to your program. Your program can then continue execution -- independent of GUI windowEvents. If your program doesn&#39;t need to do any processing after setting up all its window components and event callbacks, use the windowGuiRun() function instead.</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowGuiThreadPid(void)</font></p>
						<blockquote>
							<p>
								Returns the current GUI thread PID, if applicable, or else 0.</p>
						</blockquote>
						<p>
							<font face="Courier New">void windowGuiStop(void)</font></p>
						<blockquote>
							<p>
								Stop GUI event polling which has been started by a previous call to one of the &#39;run&#39; functions, such as windowGuiRun() or windowGuiThread().</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowNewNumberDialog(objectKey parentWindow, const char *title, const char *message, int minVal, int maxVal, int defaultVal, int *value)</font></p>
						<blockquote>
							<p>
								Create a &#39;number&#39; dialog box, with the parent window &#39;parentWindow&#39;, and the given titlebar text and main message. The dialog will have a text field for the user to enter data using the keyboard, and a slider component for adjusting it with the mouse. Minimum, maximum, and default values should be supplied. If &#39;parentWindow&#39; is NULL, the dialog box is actually created as an independent window that looks the same as a dialog. This is a blocking call that returns when the user closes the dialog window (i.e. the dialog is &#39;modal&#39;).</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowNewInfoDialog(objectKey parentWindow, const char *title, const char *message)</font></p>
						<blockquote>
							<p>
								Create an &#39;info&#39; dialog box, with the parent window &#39;parentWindow&#39;, and the given titlebar text and main message. The dialog will have a single &#39;OK&#39; button for the user to acknowledge. If &#39;parentWindow&#39; is NULL, the dialog box is actually created as an independent window that looks the same as a dialog. This is a blocking call that returns when the user closes the dialog window (i.e. the dialog is &#39;modal&#39;).</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowNewErrorDialog(objectKey parentWindow, const char *title, const char *message)</font></p>
						<blockquote>
							<p>
								Create an &#39;error&#39; dialog box, with the parent window &#39;parentWindow&#39;, and the given titlebar text and main message. The dialog will have a single &#39;OK&#39; button for the user to acknowledge. If &#39;parentWindow&#39; is NULL, the dialog box is actually created as an independent window that looks the same as a dialog. This is a blocking call that returns when the user closes the dialog window (i.e. the dialog is &#39;modal&#39;).</p>
						</blockquote>
						<p>
							<font face="Courier New">objectKey windowNewProgressDialog(objectKey parentWindow, const char *title, progress *tmpProg)</font></p>
						<blockquote>
							<p>
								Create a &#39;progress&#39; dialog box, with the parent window &#39;parentWindow&#39;, and the given titlebar text and progress structure. The dialog creates a thread which monitors the progress structure for changes, and updates the progress bar and status message appropriately. If the operation is interruptible, it will show a &#39;CANCEL&#39; button. If &#39;parentWindow&#39; is NULL, the dialog box is actually created as an independent window that looks the same as a dialog. This is a non-blocking call that returns immediately (but the dialog box itself is &#39;modal&#39;). A call to this function should eventually be followed by a call to windowProgressDialogDestroy() in order to destroy and deallocate the window.</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowProgressDialogDestroy(objectKey window)</font></p>
						<blockquote>
							<p>
								Given the objectKey for a progress dialog &#39;window&#39; previously returned by windowNewProgressDialog(), destroy and deallocate the window.</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowNewPromptDialog(objectKey parentWindow, const char *title, const char *message, int rows, int columns, char *buffer)</font></p>
						<blockquote>
							<p>
								Create a &#39;prompt&#39; dialog box, with the parent window &#39;parentWindow&#39;, and the given titlebar text and main message. The dialog will have a single text field for the user to enter data. If &#39;parentWindow&#39; is NULL, the dialog box is actually created as an independent window that looks the same as a dialog. This is a blocking call that returns when the user closes the dialog window (i.e. the dialog is &#39;modal&#39;).</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowNewPasswordDialog(objectKey parentWindow, const char *title, const char *message, int columns, char *buffer)</font></p>
						<blockquote>
							<p>
								Create a &#39;password&#39; dialog box, with the parent window &#39;parentWindow&#39;, and the given titlebar text and main message. The dialog will have a single password field. If &#39;parentWindow&#39; is NULL, the dialog box is actually created as an independent window that looks the same as a dialog. This is a blocking call that returns when the user closes the dialog window (i.e. the dialog is &#39;modal&#39;).</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowNewQueryDialog(objectKey parentWindow, const char *title, const char *message)</font></p>
						<blockquote>
							<p>
								Create a &#39;query&#39; dialog box, with the parent window &#39;parentWindow&#39;, and the given titlebar text and main message. The dialog will have an &#39;OK&#39; button and a &#39;CANCEL&#39; button. If the user presses OK, the function returns the value 1. Otherwise it returns 0. If &#39;parentWindow&#39; is NULL, the dialog box is actually created as an independent window that looks the same as a dialog. This is a blocking call that returns when the user closes the dialog window (i.e. the dialog is &#39;modal&#39;).</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowNewRadioDialog(objectKey parentWindow, const char *title, const char *message, char *choiceStrings[], int numChoices, int defaultChoice)</font></p>
						<blockquote>
							<p>
								Create a dialog window with a radio button widget with the parent window &#39;parentWindow&#39;, the given titlebar text and main message, and &#39;numChoices&#39; choices, as specified by the &#39;choiceStrings&#39;. &#39;default&#39; is the default focussed selection. The dialog&#39;s radio button widget will have items for each choice. If the user chooses one of the choices, the function returns the 0-based index of the choice. Otherwise it returns negative. If &#39;parentWindow&#39; is NULL, the dialog box is actually created as an independent window that looks the same as a dialog. This is a blocking call that returns when the user closes the dialog window (i.e. the dialog is &#39;modal&#39;).</p>
						</blockquote>
						<p>
							<font face="Courier New">objectKey windowNewThumbImage(objectKey parent, const char *fileName, unsigned maxWidth, unsigned maxHeight, componentParameters *params)</font></p>
						<blockquote>
							<p>
								Create a new window image component from the supplied image file name &#39;fileName&#39;, with the given &#39;parent&#39; window or container, and component parameters &#39;params&#39;. Dimension values &#39;maxWidth&#39; and &#39;maxHeight&#39; constrain the maximum image size. The resulting image will be scaled down, if necessary, with the aspect ratio intact. If &#39;fileName&#39; is NULL, a blank image will be created.</p>
						</blockquote>
						<p>
							<font face="Courier New">int windowThumbImageUpdate(objectKey thumbImage, const char *fileName, unsigned maxWidth, unsigned maxHeight)</font></p>
						<blockquote>
							<p>
								Update an existing window image component &#39;thumbImage&#39;, previously created with a call to windowNewThumbImage(), from the supplied image file name &#39;fileName&#39;. Dimension values &#39;maxWidth&#39; and &#39;maxHeight&#39; constrain the maximum image size. The resulting image will be scaled down, if necessary, with the aspect ratio intact. If &#39;fileName&#39; is NULL, the image will become blank.</p>
						</blockquote>
					</td>
				</tr>
			</tbody>
		</table>
	</center>
</div>
                      </div>
      </div>
    
    <div class="clearfix"></div>
    <div id="footer">                 
                                <small><br/>Copyright &copy; 1999-2014 J. Andrew McLaughlin<br/>Visopsys and Visopsys.org are trademarks of J. Andrew McLaughlin.<br/><a href="mailto:andy@visopsys.org">Contact</a> | Design by <a href="http://www.fosforito.net/">Jens L. Wagner</a><br/><br/></small>                  </div>
  <!-- End Wrap2 -->
</div>
<!-- End Wrap -->
</body>
</html>