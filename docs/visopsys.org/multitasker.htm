<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Visopsys &#126; Multitasker</title>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=iso-8859-1" />
    <link rel="stylesheet" href="blade_packs/system_razorSiteSearch/css/sitesearch.css" type="text/css" media="screen" />    <link rel="stylesheet" type="text/css" href="blade_packs/theme_ClearBlue/ClearBlue_css.css" />
    <!-- WIN IE Style Sheets -->
<!--[if IE]>
  <![if gte IE 5.5]>
   <![if gte IE 7]><link rel="stylesheet" 
	type="text/css" media="screen,projection" 
	href="ie.css" />
	<![endif]>
   <![if lt IE 7]><link rel="stylesheet" 
	type="text/css" media="screen,projection" 
	href="ie.css" />
	<![endif]>
  <![endif]>
  <![if lt IE 5.5]>
   <link rel="stylesheet"
	type="text/css" media="screen,projection" 
	href="ie.css" />
    <![endif]>
<![endif]-->
        <link rel="shortcut icon" href="favicon.ico" />
</head>
<body>
<div id="wrap">
  <div id="wrap2">
    <div id="header">

<h1 id="logo"><img src="visopsys-logo1.png" width="300px" height="85px" /></h1>

      <!--<h1 id="logo">Visopsys</h1>
            <div id="slogan">Visual Operating System</div>-->

	    <div id='searchBoxHeader'><div><form action='http://visopsys.org/razor-SiteSearch.htm' method='post'><input class='searchText' type='text' name='siteSearch' /><input class='searchButton' type='submit' value='Search' /></form></div></div>    </div>
    <div id="nav">
      <div id="nbar">
            <ul class="first"><li><a href='index.html'>Home</a></li><li><a href='about.htm'>About</a></li><li><a href='news.htm'>News</a></li><li><a href='screenshots.htm'>Screenshots</a></li><li><a href='downloads.htm'>Downloads</a></li><li><a href='forums/index.php'>Forum</a></li><li><a href='developers.htm'>Developers</a></li><li><a href='os-dev.htm'>OS Dev</a></li></ul>	             </div>
    </div>
    <div id="content-wrap">
      <div id="sidebar">
      <div id="right_sidebar">
          <div id="side_sky_ad">
          	<!-- Sidebar Sky Scraper Ad -->
            <!-- 160 x 600 Google ad code -->
                                <script type="text/javascript"><!--
					google_ad_client = "ca-pub-2784580927617241";
					/* orig */
					google_ad_slot = "8342665437";
					google_ad_width = 160;
					google_ad_height = 600;
					//-->
				  </script>
				  <script type="text/javascript"
					src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
				  </script>
          </div>
        </div>
      <!--<div id="left_sidebar">
                                Edit this sidebar with the Filemanager in<br/>
root/blade_packs/ theme_ClearBlue/ ClearBlue_xhtml.php
          </div>-->
      </div>
      <div id="content">
                <p align="left" style="color: rgb(0, 0, 0); font-family: arial; font-size: medium;">
	<b><font size="4">About Visopsys</font></b></p>
<div align="center" style="color: rgb(0, 0, 0); font-family: arial; font-size: medium;">
	<center>
		<table border="0" bordercolor="#111111" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" width="100%">
			<tbody>
				<tr>
					<td>
						THE VISOPSYS MULTITASKER AND SCHEDULER
						<p>
							OVERVIEW</p>
						<p>
							Visopsys is a multitasking operating system kernel.&nbsp; In lay terms this means that the kernel&#39;s &quot;scheduler&quot; -- a small piece of independent code inside the kernel -- parcels out small packets of time to all of the running programs in very rapid succession. &nbsp; One such running program is the operating system kernel itself.&nbsp; Since a single garden- variety microprocessor (such as x86 chips from AMD, Cyrix, or Intel) can only do one thing at a time, the illusion of multiple processes working simultaneously is achieved through this rapid switching between tasks.&nbsp; This is called &quot;task switching&quot; or &quot;context switching&quot;.&nbsp; If the multitasker is doing its job properly, and the work load is not too great, the user should never perceive that these switches are even occurring.</p>
						<p>
							What follows is a more technical description of the method by which Visopsys&#39; scheduler performs these context switches.</p>
						<p>
							Visopsys&#39; scheduler combines a number of common ideas into a cohesive algorithm. &nbsp; Its major features include:</p>
						<ul>
							<li>
								Pre-emptive</li>
							<li>
								Arbitrary number of priority queues</li>
							<li>
								Fair scheduling algorithm, except for the highest- and lowest- priority queues</li>
							<li>
								Real- time scheduling in the highest- priority queue</li>
							<li>
								Background scheduling in the lowest- priority queue</li>
						</ul>
						<p>
							Following is a description of the algorithm by which Visopsys&#39; scheduler determines task execution order.&nbsp;</p>
						<p>
							There will be two &quot;special&quot; queues in the multitasker. The first (highest- priority) queue will be the &quot;real time&quot; queue.&nbsp; When there are any processes running and ready at this priority level, they will be serviced to the exclusion of all processes from other queues. Not even the kernel process will reside in this queue.</p>
						<p>
							The last (lowest- priority) queue will be the &quot;background&quot; queue. Processes in this queue will only receive processor time when there are no ready processes in any other queue. Unlike all of the &quot;normal&quot; or &quot;middle&quot; queues, it will be entirely possible for processes in this background queue to starve.</p>
						<p>
							Because of the existence of these two special- case queues, there must be a minimum of 3 priority queues in the Visopsys multitasker.</p>
						<p>
							The number of priority queues will be flexibly based on a configuration macro in the multitasker&#39;s header file, and other than the minor restriction outlined above, is arbitrary.&nbsp; Increasing the number of priority queues introduces no extra overhead into the kernel (i.e. there really aren&#39;t separate queues). &nbsp; However, regardless of the number of queues, the &quot;special&quot; queues mentioned above will always exhibit their distinct behaviors.&nbsp;</p>
						<p>
							Thus, using these multiple priority queues, the Administrator can exercise a very fine-grained control over the performance of the various processes in the system.</p>
						<p>
							Amongst all of the processes in the &quot;normal&quot; priority queues, there will be a fair approach to scheduling. This fair algorithm utilizes a weighting scheme.&nbsp; When the scheduler gains control of the processor, each waiting task&#39;s weight is calculated.&nbsp; In the general case, the task with the highest weight &quot;wins&quot; and is granted the next timeslice.</p>
						<p>
							Among the variables which contribute to a process&#39; weight will be the following: priority, waiting time, and &quot;shortness&quot;. &nbsp; Shortness will be implemented later (shortest job first), so for now we will concentrate on priority and waiting time. The formula will look like this:</p>
						<blockquote>
							<p>
								<font face="Courier New">weight = (task priority * priority ratio) + waiting time</font></p>
						</blockquote>
						<p>
							[ 0 is the highest possible priority value. &nbsp; In the calculation above, &quot;task priority&quot; is actually the inverse of the task&#39;s real priority value.&nbsp; It is calculated as: the lowest possible priority value minus the task&#39;s priority value.&nbsp; So, for example, if the range of possible priority values was 0 (highest) through 7 (lowest), a highest- priority task would be: 7 - 0 = 7. ]</p>
						<p>
							The task&#39;s priority will be multiplied by the &quot;priority ratio&quot;.&nbsp; The priority ratio determines the importance of priority vs. waiting time in the scheduler queues.&nbsp; A priority ratio of zero, for example, would give higher- priority processes no advantage over lower- priority ones, and waiting time alone would determine execution order.&nbsp; By contrast, a very high ratio would ensure that lower- priority tasks must wait a very long time before usurping the timeslice of a higher- priority task.</p>
						<p>
							To this value will be added the current waiting time.&nbsp; The waiting time of each task in the queue starts at zero.&nbsp; Each time a task is passed over for execution by the scheduler, its waiting time value is increased by one.&nbsp; Whenever a task is selected to run by the scheduler, its waiting time value is subsequently reset to zero.</p>
						<p>
							After performing this simple calculation for each waiting task, the scheduler can select the &quot;winner&quot; by running the task with the highest weight.</p>
						<p>
							For example, if we have 4 possible priority levels, the priority ratio is set to 3, and we have two tasks waiting as follows:</p>
						<blockquote>
							<p>
								<font face="Courier New">Task #1: priority=0, waiting time=7<br />
								Task #2: priority=2, waiting time=12</font></p>
						</blockquote>
						<p>
							then</p>
						<blockquote>
							<p>
								<font face="Courier New">task1Weight = ((4 - 0) * 3) + 7&nbsp; = 19</font>&nbsp;&nbsp;&nbsp;&nbsp; &lt;- winner<br />
								<font face="Courier New">task2Weight = ((4 - 2) * 3) + 12 = 18</font></p>
						</blockquote>
						<p>
							Thus, even though task 2 has been waiting considerably longer, task 1&#39;s higher priority wins.&nbsp; However in a slightly different scenario -- using the same constants -- if we had:</p>
						<blockquote>
							<p>
								<font face="Courier New">Task 1: priority=0, waiting time=7<br />
								Task 2: priority=2, waiting time=14</font></p>
						</blockquote>
						<p>
							then</p>
						<blockquote>
							<p>
								<font face="Courier New">task1Weight = ((4 - 0) * 3) + 7&nbsp; = 19<br />
								task2Weight = ((4 - 2) * 3) + 14 = 20</font>&nbsp;&nbsp;&nbsp; &lt;- winner</p>
						</blockquote>
						<p>
							In this case, task 2 gets to run since it has been waiting long enough to overcome task 1&#39;s higher priority. This possibility helps to ensure that no processes will starve.</p>
						<p>
							A tie between the highest-weighted tasks is resolved by round- robin queue order.</p>
					</td>
				</tr>
			</tbody>
		</table>
	</center>
</div>
                      </div>
      </div>
    
    <div class="clearfix"></div>
    <div id="footer">                 
                                <small><br/>Copyright &copy; 1999-2014 J. Andrew McLaughlin<br/>Visopsys and Visopsys.org are trademarks of J. Andrew McLaughlin.<br/><a href="mailto:andy@visopsys.org">Contact</a> | Design by <a href="http://www.fosforito.net/">Jens L. Wagner</a><br/><br/></small>                  </div>
  <!-- End Wrap2 -->
</div>
<!-- End Wrap -->
</body>
</html>